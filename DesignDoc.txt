Project: AvxWindowFmIndex library




A 0b01100: 2/4 |0
C 0b10111: 4/8 |1
D 0b00011: 2/6 |2
E 0b00110: 2/5 |3
F 0b11110: 4/7 |4
G 0b11010: 2/5 |5
H 0b11011: 4/8 |6
I 0b11001: 2/6 |7
K 0b10101: 2/6 |8
L 0b11100: 2/4 |9
M 0b11101: 4/8 |10
N 0b01000: 4/5 |11
P 0b01001: 2/6 |12
Q 0b00100: 4/6 |13
R 0b10011: 2/6 |14
S 0b01010: 2/5 |15
T 0b00101: 2/6 |16
V 0b10110: 2/5 |17
W 0b00001: 4/8 |18
Y 0b00010: 4/7 |19

'l',0b11100: 2/4
'a',0b01100: 2/4
'g',0b11010: 2/5
'v', 0b10110: 2/5
'e',0b00110: 2/5
's',0b01010: 2/5
'i',0b11001: 2/6
'k',0b10101: 2/6
'r',0b10011: 2/6
'd',0b00011: 2/6
't',0b00101: 2/6
'p',0b01001: 2/6
'n',0b01000: 4/5
'q',0b00100: 4/6
'f',0b11110: 4/7
'y',0b00010: 4/7
'm',0b11101: 4/8
'h',0b11011: 4/8
'c',0b10111: 4/8
'w' 0b00001: 4/8



//TODO: make deallocFmIndex deallocate everything in index.

Goal: to provide a heavily optimized FM-index protein search implementation for use in bioinformatics pipelines.

Currently, I am aiming to make this both a software library that can be linked to (as in LibDifSufSort),
as well as a standalone executable version.



Public API:
  building:
    build FM-index from ascii full-text, given as cmd line argument string
    build FM-index from ascii full-text, given as stdin pipe      (standalone only, I think.)
    build FM-index from ascii full-text, given as raw text file (raw text, fasta, )
    build FM-index from ascii full-text, given as fasta file
    (maybe) build FM-index from ascii existing fm index file, as hmmer likes it

    save Fm-index as application specific file format (.FMI extension)
    (maybe) save FM-index as hmmer fm-index file format
    (maybe) return FM-index as structure from library code.

    reconstructFullText: rebuilds the full text by walking through the bwt from the end '$' character.


    exists function: takes arguments of kmer string, and a prebuilt FM-index structure. returns bool of if the kmer was found.
    findRangeForKmer: takes arguments of Kmer string, and prebuilt FM-index structure. returns range in BWT of occurances.
    findQueryHitsForKmer: takes arguments of kmer string, prebuilt FM-index. returns array of all positions in original full database text where found.

    backwardStep: takes arguments FM-index structure, bwt range, and prefix character. Returns range for kmer that also includes prefix.    (lib only)

    FullStringSearch: takes query sequence (or file), prebuilt FM-index. returns list of tuples [position in sequence, range of hits in bwt.] (lib only)
    FullStringQueryHits: takes query sequence (or file), prebuilt fm-index. returns array of tuples [position in sequence, position in database].

    getDbSequenceAroundHit(hitPositionInDbSeq, numCharsBefore, numCharsAfter): seeks into file, grabbing sequence around hit as a char array.


--------------------------------------------------------------------------------

project structure:

directory: Index
	AwFmIndex.h: structs for the FmIndex and lower level structs/unions.
	AwFmFastBuild.c/.h
		Builds a FmIndex from full text source, either from string or file.
	AwFmLoad.c/.h
		Loads an FmIndex from file.
	AwFmSave.c/.h
		Saves the FmIndex structure to file.

directory: Search
	AwFmOccupancy.c/h: contains all of the occupancy functions and helpers
	AwFmFastSearch.c/.h: contains backwardsStep function, exists function, and findRange functions.

directory: Error:
	AwFmError.c/.h: handles errors


Api (root directory):
	AwFmApi.h: include api for the project, contains public functions.
	AwFmRoot.h: top-level definitions, typedefs, etc.


unplaced stuff:
CharacterTransforms: converts ascii to frequency indexed characters, ascii to vector format, function for ambiguity resolution.






--------------------------------------------------------------------------------
cannonical naming convention.
files: 		pascal case
structs: 	pascal case
functions: 	camel case


--------------------------------------------------------------------------------
.awfmi File Format:
  bytes [7:0]:    8 byte header containing the text "FmIndex" and a null terminator (0x00)
  bytes [71:8]:   64 byte metadata header, containing at least a 4-byte version info integer.
                    As long as the version info is below 2^16, the rest of the versioning is defined below.
                    Versions after 2^16 are allowed to redefine the data below. These versions are undefined, and only specified for future-proofing.
                  The byte after the version info (byte 12) shall determine the bit size of the positions.
                    If Byte 12 is 0, the I array (defined below) shall be represented as 32-bit positions.
                    If Byte 12 is 1, the I array shall be represented as 64-bit positions.
                    Currently, only 64-bit I arrays are supported (byte 12 == 0 is undefined.)


  bytes [79:72]:  8 byte integer representing the number of 224-position blocks in the index
  bytes [87:80]:  8 byte integer representing the number of positions BWT array.
  bytes [95:88]:  8 byte integer indicating the position of the null terminator.
  bytes [-:96]:   The block list of the index. Each block contains a 160 byte base occupancy header
                    and 160 bytes for the position bit vectors, totaling 320 bytes per block.

  after each block is specified, the file shall contain one integer per position in the Bwt
  correlating to the I array in the traditional FM-index implementation.
  The integer bit width shall be determined by the 5th byte in the metadata (byte 12 in the file).
--------------------------------------------------------------------------------
